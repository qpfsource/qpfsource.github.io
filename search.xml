<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker的配置与软件下载</title>
      <link href="/2021/07/18/docker-de-pei-zhi-yu-ruan-jian-xia-zai/"/>
      <url>/2021/07/18/docker-de-pei-zhi-yu-ruan-jian-xia-zai/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker的配置与软件下载"><a href="#Docker的配置与软件下载" class="headerlink" title="Docker的配置与软件下载"></a>Docker的配置与软件下载</h2><h4 id="1、Docker切换设置阿里镜像源"><a href="#1、Docker切换设置阿里镜像源" class="headerlink" title="1、Docker切换设置阿里镜像源"></a>1、Docker切换设置阿里镜像源</h4><p>在Docker生态系统中，Docker默认从DockerHub中获取创建容器的对应镜像信息。但是，由于DockerHub的服务器在海外，这样我们访问下载镜像的速度将大大受限，极有可能因为网络原因出现连接下载异常的情况，此时，我们可通过更换Docker的默认镜像源来解决此问题。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 下载5.7版本的Mysql镜像docker pull mysql:5.7-- 显示Docker中下载的镜像信息docker images <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 配置Docker镜像地址为阿里云的镜像加速站sudo mkdir -p /etc/docker;sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://4y7xkk5s.mirror.aliyuncs.com"]}EOF;sudo systemctl daemon-reload;sudo systemctl restart docker;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、Docker安装并启动Mysql"><a href="#2、Docker安装并启动Mysql" class="headerlink" title="2、Docker安装并启动Mysql"></a>2、Docker安装并启动Mysql</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 创建Mysql容器并启动docker run -p 3306:3306 --name mysql\ -v /mydata/mysql/log:/var/log/mysql\-v /mydata/mysql/data:/var/lib/mysql\-v /mydata/mysql/conf:/etc/mysql\-e MYSQL_ROOT_PASSWORD=root\-d mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述安装命令的解释如下:</p><p>1、—p:3306:3306:将容器的3306端口映射到主机的3306端口上。</p><p>2、—v  /mydata/mysql/conf:/etc/mysql\  :将配置文件挂载到主机。</p><p>3、—v  /mydata/mysql/log:/var/log/mysql:将日志文件挂载到主机。</p><p>4、—v  /mydata/mysql/conf:/etc/mysql:将配置文件挂载到主机。</p><p>5、—e  MYSQL_ROOT_PASSWORD=root:初始化root用户的账户和密码信息。</p><p>6、—d  mysql:5.7:启动容器使用的镜像版本。</p><p>7、–name:表示创建容器的名称。</p></blockquote><h5 id="进入已创建的mysql容器的内部"><a href="#进入已创建的mysql容器的内部" class="headerlink" title="进入已创建的mysql容器的内部:"></a>进入已创建的mysql容器的内部:</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 进入到已创建的mysql容器中docker exec -it mysql /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3、Docker安装并启动Redis"><a href="#3、Docker安装并启动Redis" class="headerlink" title="3、Docker安装并启动Redis"></a>3、Docker安装并启动Redis</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 下载redis的镜像信息docker pull redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 创建需要挂载的配置文件mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 创建redis实例并启动docker run -p 6379:6379 --name redis\-v /mydata/redis/data:/data\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf\-d redis redis-server /etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述安装命令的解释如下:</p><p>1、-p 6379:6379 :表示将容器的3306端口挂载到主机的3306端口上。</p><p>2、–name:表示当前创建的容器的名称。</p><p>3、-v /mydata/redis/data:/data:表示将容器中的数据目录挂载到主机的宿主目录中。</p><p>4、-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf:表示将容器的配置文件挂载到主机的宿主目录中。</p><p>5、-d redis redis-server /etc/redis/redis.conf:启动redis服务，并且以/etc/redis/redis.conf的配置文件启动。</p></blockquote><h5 id="设置Docker容器的自启动"><a href="#设置Docker容器的自启动" class="headerlink" title="设置Docker容器的自启动:"></a>设置Docker容器的自启动:</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 设置redis容器在docker启动时自启动docker update redis  --restart=always<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装与使用</title>
      <link href="/2021/07/18/docker-de-an-zhuang-yu-shi-yong/"/>
      <url>/2021/07/18/docker-de-an-zhuang-yu-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="认识Docker"><a href="#认识Docker" class="headerlink" title="认识Docker"></a>认识Docker</h2><h3 id="1、Docker介绍与历史"><a href="#1、Docker介绍与历史" class="headerlink" title="1、Docker介绍与历史"></a>1、Docker介绍与历史</h3><h4 id="1-1、Docker的简单介绍"><a href="#1-1、Docker的简单介绍" class="headerlink" title="1.1、Docker的简单介绍"></a>1.1、Docker的简单介绍</h4><p>Docker是一个用于开发，发布和运行应用程序的开放平台。Docker使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h4 id="1-2、Docker的历史"><a href="#1-2、Docker的历史" class="headerlink" title="1.2、Docker的历史"></a>1.2、Docker的历史</h4><p>Docker 公司起初是一家名为 dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。</p><p>底层技术上，dotCloud 平台利用了 Linux 容器技术。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的！</p><p>2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。于是他们聘请了 Ben Golub 作为新的 CEO，将公司重命名为“Docker”，放弃dotCloud PaaS 平台，怀揣着“将 Docker 和容器技术推向全世界”的使命，开启了一段新的征程。(Docker于2013年开源)</p><p>如今 Docker 公司被普遍认为是一家创新型科技公司，据说其市场价值约为 10 亿美元。Docker 公司已经通过多轮融资，吸纳了来自硅谷的几家风投公司的累计超过 2.4 亿美元的投资。</p><h4 id="1-3、Docker与虚拟机"><a href="#1-3、Docker与虚拟机" class="headerlink" title="1.3、Docker与虚拟机"></a>1.3、Docker与虚拟机</h4><p>在Docker未诞生之前，我们一般会使用虚拟机技术来实现我们的日常工作需求:</p><p>Docker和虚拟机的区别:</p><p>虚拟机是目前在IT架构中运用最广泛的一种虚拟化技术，它的目的主要是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，并且提高服务器的利用率。观察一下虚拟机的架构图：</p><p><img src="http://md.qpfsource.cn/img/vmobj1.png"></p><p> <strong>Infrastructure：为基础设施</strong>，他可以是个笔记本电脑，也可以是一个服务器机柜，还可以是一个云主机。</p><p>  <strong>Host Operating System：为主机的物理操作系统</strong>，是管理计算机硬件与软件资源的计算机程序。</p><p>  <strong>Hypervisor：为虚拟机监视器</strong>，是一种运行在基础物理服务器和虚拟操作系统间的中间软件层，可允许多个虚拟操作系统和应用共享硬件。</p><p> <strong>Guest OS：虚拟操作系统</strong>，虚拟机内部运行的操作系统。</p><p> <strong>Bins/Libs：具体的二进制文件和库文件</strong>，保存一些工具和用户空间的库。</p><p> <strong>APP：用户应用程序。</strong></p><p><strong>Docker：</strong>是一个应用容器引擎，让开发者可以打包应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Window机器上，也可以实现虚拟化。我们再来看一下Docker的架构图：</p><p><img src="http://md.qpfsource.cn/img/vmobj2.png"></p><p>可以看到Docker和虚拟机的区别在于，Docker没有Hypervisor（虚拟机监视器）这一层，因为Docker本身就是一个系统级的虚拟化技术，所以它要基于已有的操作系统去安装。</p><p><strong>Docker与虚拟机的简单对比:</strong></p><table><thead><tr><th>对比项</th><th>Container（容器）</th><th>VM（虚拟机）</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>运行性能</td><td>接近原生</td><td>有所损失</td></tr><tr><td>磁盘占用</td><td>MB</td><td>GB</td></tr><tr><td>数量</td><td>成百上千</td><td>一般几十台</td></tr><tr><td>隔离性</td><td>进程级别</td><td>系统级别</td></tr><tr><td>操作系统</td><td>几乎所有</td><td>几乎所有</td></tr><tr><td>封装程度</td><td>只打包项目代码和依赖关系，共享宿主机内核</td><td>完整的操作系统</td></tr></tbody></table><ul><li><strong>启动速度：</strong>因为VM是一个完整的操作系统包括硬件和内核，所以它是一个重量级的系统；而容器是轻量级的，因为容器只打包了操作系统的基础文件和库文件、还有应用程序及所有的依赖，他的运行速度就好比在一台机器上创建一个进程一样，所以启动速度较快。</li><li><strong>运行性能</strong>：由于VM增加了Hypervisor层用于虚拟化硬件，势必会增加一定的开销，所以运行性能有所损失；而容器是直接运行在物理操作系统上的，他本身与系统上其他进程并没有太大区别，所以运行性能是接近原生的。</li><li><strong>磁盘占用：</strong>VM是一个完整的操作系统，所以为GB级别的；而容器只包含了一些系统启动的必要组件和程序依赖，所以是MB级别的。</li><li><strong>隔离性：</strong>虚拟机是一个完整的操作系统级别的隔离，要比容器好很多；容器是进程级别的隔离，隔离的不彻底，因为多个容器之间使用的是同一个宿主机的操作系统内核。</li></ul><h4 id="1-4、Docker的基本组成"><a href="#1-4、Docker的基本组成" class="headerlink" title="1.4、Docker的基本组成"></a>1.4、Docker的基本组成</h4><p><img src="http://md.qpfsource.cn/img/docker1.jpg"></p><p><strong>镜像(image)：</strong>docker镜像好比一个操作系统模板，这个模板是只读的。我们可以使用该镜像来创建容器，一个镜像可以创建多个容器。</p><p><strong>容器(container)：</strong>Docker利用容器来独立运行一个或一组应用，容器就是使用镜像创建的运行实例。容器创建后可以手动对其进行启动、停止、删除等不同的操作。每个不同的容器之间是相互隔离的，可以保证平台的安全性。</p><p>我们可以将容器简单的理解为一个简易版本的Linux环境，该环境中包括当前容器运行的基本环境信息和对应的应用程序。</p><p><strong>仓库(repository)：</strong>仓库就是用来存储镜像的位置。仓库一般分为公有仓库和私有仓库两种不同的形式。目前，最大的仓库是<a href="%22https://www.dockerhub.com">DockerHub</a>,该网站服务器在国外，这里一般需要设置镜像加速，如阿里云、华为云等。</p><h3 id="2、Docker的安装与配置"><a href="#2、Docker的安装与配置" class="headerlink" title="2、Docker的安装与配置"></a>2、Docker的安装与配置</h3><h4 id="2-1、Docker的安装"><a href="#2-1、Docker的安装" class="headerlink" title="2.1、Docker的安装"></a>2.1、Docker的安装</h4><h5 id="2-1-1、查看系统内核版本"><a href="#2-1-1、查看系统内核版本" class="headerlink" title="2.1.1、查看系统内核版本"></a>2.1.1、查看系统内核版本</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 系统内核版本必须为3.0以上[root@mysvr ~]# uname -r3.10.0-957.5.1.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-1-2、卸载旧版本"><a href="#2-1-2、卸载旧版本" class="headerlink" title="2.1.2、卸载旧版本"></a>2.1.2、卸载旧版本</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-1-3、安装需要的安装包"><a href="#2-1-3、安装需要的安装包" class="headerlink" title="2.1.3、安装需要的安装包"></a>2.1.3、安装需要的安装包</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo yum install -y yum-utils-- 此处该仓库的地址可选用国内的加速地址，默认地址为国外的镜像地址sudo yum-config-manager \    --add-repo \    （https://download.docker.com/linux/centos/docker-ce.repo）   -- 不推荐使用sudo yum-config-manager \    --add-repo \     [http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo]  -- 推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-1-4、安装docker相关的内容"><a href="#2-1-4、安装docker相关的内容" class="headerlink" title="2.1.4、安装docker相关的内容"></a>2.1.4、安装docker相关的内容</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo yum install docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-1-5、启动docker服务"><a href="#2-1-5、启动docker服务" class="headerlink" title="2.1.5、启动docker服务"></a>2.1.5、启动docker服务</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-1-6、查看docker安装的版本信息"><a href="#2-1-6、查看docker安装的版本信息" class="headerlink" title="2.1.6、查看docker安装的版本信息"></a>2.1.6、查看docker安装的版本信息</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# docker --versionDocker version 20.10.1, build 831ebea<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-1-7、docker容器测试"><a href="#2-1-7、docker容器测试" class="headerlink" title="2.1.7、docker容器测试"></a>2.1.7、docker容器测试</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://md.qpfsource.cn/img/dockers1.png"></p><h5 id="2-1-8、查看下载的镜像"><a href="#2-1-8、查看下载的镜像" class="headerlink" title="2.1.8、查看下载的镜像"></a>2.1.8、查看下载的镜像</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    bf756fb1ae65   12 months ago   13.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-1-9、卸载docker环境"><a href="#2-1-9、卸载docker环境" class="headerlink" title="2.1.9、卸载docker环境"></a>2.1.9、卸载docker环境</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">sudo yum remove docker-ce docker-ce-cli containerd.io   -- 卸载docker依赖sudo rm -rf /var/lib/docker  -- 删除docker运行资源路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2、配置Docker的阿里云镜像加速"><a href="#2-2、配置Docker的阿里云镜像加速" class="headerlink" title="2.2、配置Docker的阿里云镜像加速"></a>2.2、配置Docker的阿里云镜像加速</h4><h5 id="2-2-1、登录阿里云控制台，获取加速地址"><a href="#2-2-1、登录阿里云控制台，获取加速地址" class="headerlink" title="2.2.1、登录阿里云控制台，获取加速地址"></a>2.2.1、登录阿里云控制台，获取加速地址</h5><p><img src="http://md.qpfsource.cn/img/aliyundo.png"></p><p><img src="http://md.qpfsource.cn/img/aliyunoss12.png"></p><p>根据不同的操作系统选择对应的解决方案:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 此处使用centos的加速方案1、sudo mkdir -p /etc/docker2、sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://4y7xkk5s.mirror.aliyuncs.com"]}EOF3、sudo systemctl daemon-reload4、sudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、Docker的底层原理"><a href="#3、Docker的底层原理" class="headerlink" title="3、Docker的底层原理"></a>3、Docker的底层原理</h4><h5 id="3-1、Docker是如何工作的？"><a href="#3-1、Docker是如何工作的？" class="headerlink" title="3.1、Docker是如何工作的？"></a>3.1、Docker是如何工作的？</h5><p>Docker是一个Client -Server结构的系统，Docker的守护进程运行在宿主机上。通过Socket从客户端访问，当Docker Server接收到Docker-Client的指令后，就会执行该指令。</p><p><img src="http://md.qpfsource.cn/img/dockeeqq.png"></p><h5 id="3-2、Docker的常用命令"><a href="#3-2、Docker的常用命令" class="headerlink" title="3.2、Docker的常用命令"></a>3.2、Docker的常用命令</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker version -- 显示docker的版本信息docker info -- 显示docker的详细的系统信息docker 命令  --help  -- 显示相关docker命令的帮助信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>docker帮助文档地址:<a href="https://docs.docker.com/engine/reference,%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E5%9D%87%E5%8F%AF%E9%80%9A%E8%BF%87%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E8%8E%B7%E5%BE%97%E3%80%82">https://docs.docker.com/engine/reference,相关命令的详细信息均可通过帮助文档获得。</a></p></blockquote><h3 id="4、Docker的常用命令"><a href="#4、Docker的常用命令" class="headerlink" title="4、Docker的常用命令"></a>4、Docker的常用命令</h3><h4 id="4-1、镜像命令"><a href="#4-1、镜像命令" class="headerlink" title="4.1、镜像命令"></a>4.1、镜像命令</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker images  -- 查看所有本地主机上的镜像[ -a (显示所有) -f (过滤) -q (只显示id)]docker search  -- 搜索相关镜像[-f(过滤) ]  --filter=STARS=3000，表示查询star&gt;3000的镜像docker pull    -- 下载镜像，默认下载最新版本，可手动指定  docker pull mysql:5.7docker rmi     -- 删除镜像，可通过名称或id进行删除 [-f 表示强制删除] docker rmi -f $(docker images -aq)  -- 删除当前宿主机上的所有镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2、容器命令"><a href="#4-2、容器命令" class="headerlink" title="4.2、容器命令"></a>4.2、容器命令</h4><blockquote><p>说明:容器的存在的前提是必须首先存在对应的镜像，下载一个centos镜像。</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker run [可选参数] image参数说明:--name:指定容器的名称-d:指定以后台的方式运行-it:使用交互模式运行-p:指定容器的端口信息 8080:8080[主机端口:容器端口]-P:随机指定端口 [root@mysvr ~]# docker run -it centos /bin/bash  -- 启动并进入容器docker ps --列出当前运行中的所有容器[-a 表示运行过的所有容器  -n=X 显示最近创建的X个容器 -q只显示编号]容器不停止退出  --- Ctrl+p+qdocker rm   -- 删除容器，可根据名称或id删除指定容器  删除所有容器:[docker rm -f $(docker ps -aq)]docker ps -aq|xargs docker rm  -- 删除所有容器docker start   容器id  -- 启动对应的容器docker restart 容器id  -- 重启对应的容器docker stop    容器id  -- 停止当前正在运行的容器docker kill    容器id  -- 强制停止当前容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3、常用的其它命令"><a href="#4-3、常用的其它命令" class="headerlink" title="4.3、常用的其它命令"></a>4.3、常用的其它命令</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker run -d  -- 后台启动容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意:当容器启动后，我们可能会发现启动的容器立即停止了。因为docker使用后台运行，就必须存在前台进程。容器启动后发现自己并未提供任何服务，此时就会自动停止。</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker logs  -- 查看日志docker logs -f -t --tail  n  容器id  -- 查询指定容器的日志信息,n表示显示的行数docker logs -f -t  容器id  -- 显示对应容器的所有日志docker run -d centos /bin/sh -c "while true;do echo Test source;sleep 1;done" -c后面为命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 查看容器中的进程信息docker top 容器id [root@mysvr ~]# docker top 65d7b4UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                20858               20820               0                   16:12               ?                   00:00:00            /bin/sh -c while true;do echo Test source;sleep 1;doneroot                21304               20858               0                   16:18               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 查看镜像的元数据docker  inspect 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 进入当前正在运行的容器docker exec -it 容器id  bin/bash    -- 进入容器后打开一个新的终端docker attach 容器id     -- 进入容器正在执行的终端<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 从容器内拷贝指定文件到宿主机中docker cp  容器id:容器内路径   目的的宿主机路径docker cp  6562ewc:/home/test.java  /home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-4、Docker的常用命令小结"><a href="#4-4、Docker的常用命令小结" class="headerlink" title="4.4、Docker的常用命令小结"></a>4.4、Docker的常用命令小结</h4><p><img src="http://md.qpfsource.cn/img/dockerssq.png"></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">查找镜像：docker search 镜像名拉取镜像：docker pull查看镜像：docker images删除镜像：docker rmi 镜像id清理镜像：docker image prune创建容器：docker run --name 别名 -d -p 8080:8080 镜像名查看所有容器：docker ps -a查看运行的容器：docker ps删除容器：docker rm [OPTIONS] 容器名重启容器：docker restart 容器ID停止容器：docker stop |docker kill 容器id进入容器：docker exec -it 容器ID /bin/bash 查看日志：docker logs -f 容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、Docker安装环境"><a href="#5、Docker安装环境" class="headerlink" title="5、Docker安装环境"></a>5、Docker安装环境</h3><h4 id="5-1、Docker安装Nginx"><a href="#5-1、Docker安装Nginx" class="headerlink" title="5.1、Docker安装Nginx"></a>5.1、Docker安装Nginx</h4><h5 id="5-1-1、下载镜像"><a href="#5-1-1、下载镜像" class="headerlink" title="5.1.1、下载镜像"></a>5.1.1、下载镜像</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker pull nginx   -- 下载nginx镜像<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="5-1-2、使用镜像启动容器"><a href="#5-1-2、使用镜像启动容器" class="headerlink" title="5.1.2、使用镜像启动容器"></a>5.1.2、使用镜像启动容器</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker run --name nginx -d -p 3334:80  nginx  -- 启动nginx,并进行端口映射<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="5-1-3、测试访问"><a href="#5-1-3、测试访问" class="headerlink" title="5.1.3、测试访问"></a>5.1.3、测试访问</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# curl localhost:3334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body {        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2、Docker安装Tomcat"><a href="#5-2、Docker安装Tomcat" class="headerlink" title="5.2、Docker安装Tomcat"></a>5.2、Docker安装Tomcat</h4><h5 id="5-2-1、下载镜像"><a href="#5-2-1、下载镜像" class="headerlink" title="5.2.1、下载镜像"></a>5.2.1、下载镜像</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker pull tomcat    -- 下载tomcat镜像<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="5-2-2、启动容器"><a href="#5-2-2、启动容器" class="headerlink" title="5.2.2、启动容器"></a>5.2.2、启动容器</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker run --name tomcate -d -p 8080:8080 tomcat  -- 启动tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="5-2-3、测试访问"><a href="#5-2-3、测试访问" class="headerlink" title="5.2.3、测试访问"></a>5.2.3、测试访问</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# curl localhost:8080&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type="text/css"&gt;body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class="line" /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class="line" /&gt;&lt;h3&gt;Apache Tomcat/9.0.41&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6、Docker的文件系统"><a href="#6、Docker的文件系统" class="headerlink" title="6、Docker的文件系统"></a>6、Docker的文件系统</h3><h4 id="6-1、UnionFS-联合文件系统"><a href="#6-1、UnionFS-联合文件系统" class="headerlink" title="6.1、UnionFS(联合文件系统)"></a>6.1、UnionFS(联合文件系统)</h4><p>Union文件系统(UnionFS) 是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层文件和目录。</p><h4 id="6-2、Docker-镜像加载原理"><a href="#6-2、Docker-镜像加载原理" class="headerlink" title="6.2、Docker 镜像加载原理"></a>6.2、Docker 镜像加载原理</h4><p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是联合文件系统(UnionFS)。</p><p>bootfs(boot file system—&gt;boot文件系统) 主要包含bootloader(boot加载器)和kernel(内核)，其中boot加载器主要是用来引导加载内核。Linux刚启动时会加载bootfs(boot文件系统)，在Docker镜像的最底层是bootfs(boot文件系统)。这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs(boot文件系统)转交给内核，此时系统就会卸载bootfs(boot文件系统)。</p><p>roorfs （root file system—&gt;root文件系统），在bootfs(boot文件系统)之上。包含的就是典型Linux系统中的 /dev ，/proc，/bin ，/etc 等标准的目录和文件。rootfs(root文件系统)就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p>对于一个精简的OS(操作系统)，rootfs(root文件系统)可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host(宿主机)的kernel(内核)，自己只需要提供rootfs(root文件系统)就行了，由此可见对于不同的Linux发行版，bootfs(boot文件系统)基本是一致的，rootfs(root文件系统)会有差别，因此不同的发行版(如Ubuntu，Centos等)可以公用bootfs(boot文件系统)。</p><p><img src="http://md.qpfsource.cn/img/dockerfios.png"></p><p><img src="http://md.qpfsource.cn/img/dockefik.jpeg"></p><ul><li>最上层是可读写的容器层</li></ul><blockquote><p>运行的容器会在镜像上面多加一层可读写的容器层, 任何对文件的更改都只存在容器层. 因此任何对容器的操作均不会影响到镜像。</p></blockquote><ul><li>容器层以下的所有镜像层都是只读的，不可修改。</li><li>上层镜像依赖下层镜像, 从上往下依次查找文件。</li><li>最底层是基础镜像。</li></ul><blockquote><p>基础镜像提供的是最小安装的linux发行版</p></blockquote><ul><li>共享宿主机内核。</li></ul><blockquote><p>bootfs主要包含bootlooder和kernel, bootloader主要是引导加载kernel, 当kernel被加载到内存中后, bootfs会被卸载以节约内存资源。</p></blockquote><h4 id="6-3、docker镜像的Commit"><a href="#6-3、docker镜像的Commit" class="headerlink" title="6.3、docker镜像的Commit"></a>6.3、docker镜像的Commit</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">docker commit 提交容器成为一个新的副本镜像-- 该命令和git命令类似docker commit -m="提交的信息" -a="作者信息"  容器id  目标镜像名:tagcp -r  ./webapps.dist/* ./webapps  -- 导入tomcate中的默认项目并提交新的副本镜像docker commit -a="source" -m="add webapp" 775c320757a9 tomcat:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 查看创建的副本是否成功创建[root@mysvr ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED          SIZEtomcat       1.0       fb6b691c803f   10 seconds ago   654MBtomcat       latest    feba8d001e3f   2 weeks ago      649MBnginx        latest    ae2feff98a0c   2 weeks ago      133MBcentos       latest    300e315adb2f   3 weeks ago      209MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、容器数据卷"><a href="#7、容器数据卷" class="headerlink" title="7、容器数据卷"></a>7、容器数据卷</h3><h4 id="7-1、容器数据卷的简介"><a href="#7-1、容器数据卷的简介" class="headerlink" title="7.1、容器数据卷的简介"></a>7.1、容器数据卷的简介</h4><p>docker的理念就是希望将我们的应用和环境整体打包成一个镜像。但是，我们的程序往往是需要保存数据的，如果将数据直接放在容器中，那么，当对应的容器被删除时，相关的数据也会一并进行删除，无法找回。</p><p>此时,我们就希望实现数据的持久化存储,为了能将程序中对应的数据进行持久化存储,我们就需要使用到数据卷的概念,实现容器之间的数据共享。</p><p>使用容器的数据卷技术，我们可以实现将docker容器中产生的数据同步至本地的宿主机中(目录挂载)。</p><p>使用数据卷可以实现docker容器和宿主机之间的数据同步，同时，也可以实现多个docker容器之间的数据同步。</p><h4 id="7-2、数据卷的挂载"><a href="#7-2、数据卷的挂载" class="headerlink" title="7.2、数据卷的挂载"></a>7.2、数据卷的挂载</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 直接使用命令进行挂载docker run -it -v 主机目录:容器内目录 centos /bin/bash[root@mysvr /]# docker run -it  -v /docker/data:/home centos /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-3、实现mysql数据目录的挂载"><a href="#7-3、实现mysql数据目录的挂载" class="headerlink" title="7.3、实现mysql数据目录的挂载"></a>7.3、实现mysql数据目录的挂载</h4><blockquote><p>思考:我们为了保证Mysql中的数据完整性与准确性，我们应如何保存其内部的数据呢？</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 下载mysql镜像docker pull mysql:5.7   -- 下载指定版本的mysql镜像文件docker run -d -p 3306:3306 -v /docker/mysql/conf:/etc/mysql/conf.d  -- 挂载配置文件-v /docker/mysql/data:/var/lib/mysql  -- 挂载数据文件目录-e MYSQL_ROOT_PASSWORD=123456  -- 设置root用户密码 mysql5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-4、具名挂载与匿名挂载"><a href="#7-4、具名挂载与匿名挂载" class="headerlink" title="7.4、具名挂载与匿名挂载"></a>7.4、具名挂载与匿名挂载</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">1、匿名挂载docker run -d -P --name nginx01 -v /etc/nginx  nginxdocker volume --help  --查看docker volume命令的帮助信息# 查看所有的卷的情况,这种是匿名挂载，因为在挂载时未指定容器外路径[root@mysvr data]# docker volume lsDRIVER    VOLUME NAMElocal     f1b4ff2f78c244ac1ef9ee58dc50af8a9af4121abe2be0084606290741240401 [匿名卷挂载]2、具名挂载docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx nginx [root@mysvr data]# docker volume lsDRIVER    VOLUME NAMElocal      juming_nginx [具名挂载]# 查看对应的卷docker volume inspect   juming_nginx# 对应的卷所在的位置为:相关的数据卷均在:var/lib/docker/volumes目录下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-5、DockerFile实现挂载"><a href="#7-5、DockerFile实现挂载" class="headerlink" title="7.5、DockerFile实现挂载"></a>7.5、DockerFile实现挂载</h4><blockquote><p>DockerFile就是用来构建docker镜像的构建文件，实际就是一个构建脚本,通过该构建脚本可以生成一个镜像。因为docker镜像是一层一层的，对应的脚本也是一个个的命令，每个命令都是一层:</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 使用dockerfile实现数据挂载,dockerfile文件内容如下：# 指令(大写)   参数FROM centosVOLUME ["volume01","volume02"]  -- 这里是匿名挂载CMD echo "----end-----"CMD /bin/bash-- 构建镜像,在当前目录下使用对应的dockerfile文件创建一个source/centos的镜像docker build -f /docker/data/dockerfile1 -t source/centos:1.0  .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-6、数据卷容器"><a href="#7-6、数据卷容器" class="headerlink" title="7.6、数据卷容器"></a>7.6、数据卷容器</h4><blockquote><p>多个mysql之间的数据如何同步？</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 通过volumes-from 实现数据卷的挂载docker run -it --name docker01 source/centos:1.0docker run -it --name docker02 --volumes-from docker01 source/centos:1.0docker run -it --name docker03 --volumes-from docker01 source/centos:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此时我们实现了将docker01创建的数据卷挂载到了docker02和docker03中，实现了数据卷的共享。</p></blockquote><h3 id="8、DockerFile"><a href="#8、DockerFile" class="headerlink" title="8、DockerFile"></a>8、DockerFile</h3><p>DockerFile是用来构建docker镜像的文件，其实就是一组命令参数脚本。</p><h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤:"></a>构建步骤:</h4><h4 id="8-1、编写dockerfile文件"><a href="#8-1、编写dockerfile文件" class="headerlink" title="8.1、编写dockerfile文件"></a>8.1、编写dockerfile文件</h4><h5 id="8-1-1、dockerfile的基本命令"><a href="#8-1-1、dockerfile的基本命令" class="headerlink" title="8.1.1、dockerfile的基本命令"></a>8.1.1、dockerfile的基本命令</h5><ol><li>每个保留关键字(指令)都必须是大写字母</li><li>执行顺序是由上往下顺序执行</li><li>#开头的内容表示注释</li><li>每一个指令都会创建提交一个新的镜像层并提交</li></ol><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">FROM             -- 基础镜像，一切从这里开始构建MAINTAINER       -- 镜像的作者RUN              -- docker镜像构建是需要运行的命令ADD              -- 步骤，tomcate镜像，这里添加Tomcate的压缩包WORKDIR          -- 工作目录VOLUME         -- 挂载的目录EXPOSE           -- 指定暴露端口配置CMD -- 指定容器启动时需要运行的指令，只有最后一个会生效，可被替代ENTPYPOINT       -- 指定容器启动时需要运行的指令，可以追加命令ONBUILD          -- 当构建一个被继承DockeFile的时候，此时会执行ONBUILD指令，触发指令COPY -- 类似ADD，净文件拷贝到镜像中ENV              -- 构建时设置环境变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-1-2、实现自定义centos的DockerFile"><a href="#8-1-2、实现自定义centos的DockerFile" class="headerlink" title="8.1.2、实现自定义centos的DockerFile"></a>8.1.2、实现自定义centos的DockerFile</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">FROM centosMAINTAINER source&lt;1032576593@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80 CMD echo $MYPATHCMD echo "------end-------"CMD /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-2、docker-build-构建镜像"><a href="#8-2、docker-build-构建镜像" class="headerlink" title="8.2、docker build  构建镜像"></a>8.2、docker build  构建镜像</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">构建镜像:-f :表示使用的dockerfile的文件位置-t ：表示生成的目标镜像的名称及对应的tagdocker build -f dockerfile2 -t mycentos:1.0 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-3、docker-run-运行镜像"><a href="#8-3、docker-run-运行镜像" class="headerlink" title="8.3、docker  run 运行镜像"></a>8.3、docker  run 运行镜像</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 运行构建完成的镜像docker run -it mycentos:1.0docker history  镜像id  -- 查看镜像的构建过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="8-4、CMD与ENTPYPOINT的区别"><a href="#8-4、CMD与ENTPYPOINT的区别" class="headerlink" title="8.4、CMD与ENTPYPOINT的区别"></a>8.4、CMD与ENTPYPOINT的区别</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- dockerfile文件如下[CMD测试]FROM centosCMD ["ls","-a"]-- CMD  在执行时追加命令，此时会将文件中的命令替换掉-- ENTPYPOINT 在执行时追加命令，此时会直接追加在dockerfile文件的命令后面，不会进行替换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-5、Tomcat镜像"><a href="#8-5、Tomcat镜像" class="headerlink" title="8.5、Tomcat镜像"></a>8.5、Tomcat镜像</h4><h5 id="8-5-1、准备镜像文件tomcate和jdk的压缩包"><a href="#8-5-1、准备镜像文件tomcate和jdk的压缩包" class="headerlink" title="8.5.1、准备镜像文件tomcate和jdk的压缩包"></a>8.5.1、准备镜像文件tomcate和jdk的压缩包</h5><h5 id="8-5-2、编写Dockerfile文件"><a href="#8-5-2、编写Dockerfile文件" class="headerlink" title="8.5.2、编写Dockerfile文件"></a>8.5.2、编写Dockerfile文件</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">FROM centosMAINTAINER source&lt;1032576593@qq.com&gt;COPY readme.txt   /usr/local/readme.txtADD jdk-8u111-linux-x64.tar.gz   /usr/localADD apache-tomcat-9.0.22.tar.gz  /usr/localRUN yum -y install vimENV MYPATH  /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_111ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22ENV CATA_BASE /usr/local/apache-tomcat-9.0.22ENV PATH $PATH:$JAVA_HOME:/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcate-9.0.22/bin/startup.sh &amp;&amp; tailf /usr/local/apache-tomcate-9.0.22/logs/catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-4、docker-push-发布镜像"><a href="#8-4、docker-push-发布镜像" class="headerlink" title="8.4、docker push 发布镜像"></a>8.4、docker push 发布镜像</h4><h5 id="8-4-1、发布镜像到DockerHub"><a href="#8-4-1、发布镜像到DockerHub" class="headerlink" title="8.4.1、发布镜像到DockerHub"></a>8.4.1、发布镜像到DockerHub</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 注册账号，确定可以登录docker login --helpdocker login -u username-- 输入登录的密码docker push username/divtomcate:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-4-2、发布镜像到阿里云"><a href="#8-4-2、发布镜像到阿里云" class="headerlink" title="8.4.2、发布镜像到阿里云"></a>8.4.2、发布镜像到阿里云</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 1、登录阿里云，找到容器镜像服务-- 2、创建命名空间-- 3、 创建容器镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9、Docker网络"><a href="#9、Docker网络" class="headerlink" title="9、Docker网络"></a>9、Docker网络</h3><h4 id="9-1、认识Docker0"><a href="#9-1、认识Docker0" class="headerlink" title="9.1、认识Docker0"></a>9.1、认识Docker0</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000lo:表示本机回环地址    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000  eth0:表示阿里云内网地址    link/ether 00:16:3e:10:c6:68 brd ff:ff:ff:ff:ff:ff    inet 172.17.2.28/20 brd 172.17.15.255 scope global dynamic eth0       valid_lft 312945520sec preferred_lft 312945520sec3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default  docker0:表示docker生层的地址    link/ether 02:42:58:3d:bc:8d brd ff:ff:ff:ff:ff:ff    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>思考：docker 是如何处理容器网络访问的？</p></blockquote><p><img src="http://md.qpfsource.cn/img/internet.png"></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 启动一个tomcate容器docker run -d -P --name tomcate01 tomcat# 查看容器内部的网络 ip addr ，发现当容器启动时会得到一个eth0@if43的IP地址，这个地址是docker分配的# 在每个容器中都会有这样的一个ip地址[root@mysvr ~]# docker exec -it tomcate01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever42: eth0@if43: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0       valid_lft forever preferred_lft forever# 1、测试,Linux能否和容器内部进行网络通信？[root@mysvr ~]# ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.085 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.058 ms64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.066 ms结论:通过测试我们发现Linux可以和docker容器内部实现网络通信<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Docker网络的工作原理:</p><p>1、我们每启动一个docker容器，docker就会给相关的容器分配一个ip,就会有一个网卡docker0,该网卡使用桥接的网络模式，使用的技术是evth-pair技术。</p></blockquote><p>再次测试Linux内部的网络环境，发现内容如下:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:16:3e:10:c6:68 brd ff:ff:ff:ff:ff:ff    inet 172.17.2.28/20 brd 172.17.15.255 scope global dynamic eth0       valid_lft 312944135sec preferred_lft 312944135sec3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:58:3d:bc:8d brd ff:ff:ff:ff:ff:ff    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0       valid_lft forever preferred_lft forever43: veth055c4af@if42: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default   该ip是创建容器时默认生成的，和容器内的网络环境进行绑定    link/ether ea:3b:0c:4b:ee:90 brd ff:ff:ff:ff:ff:ff link-netnsid 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次启动一个新的容器进行测试，查看网络环境:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:16:3e:10:c6:68 brd ff:ff:ff:ff:ff:ff    inet 172.17.2.28/20 brd 172.17.15.255 scope global dynamic eth0       valid_lft 312943940sec preferred_lft 312943940sec3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:58:3d:bc:8d brd ff:ff:ff:ff:ff:ff    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0       valid_lft forever preferred_lft forever43: veth055c4af@if42: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether ea:3b:0c:4b:ee:90 brd ff:ff:ff:ff:ff:ff link-netnsid 045: vetha9e6ec6@if44: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default   -- 这里又多出一块被分配的ip及网卡信息    link/ether aa:f8:f1:73:d3:18 brd ff:ff:ff:ff:ff:ff link-netnsid 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述的测试我们发现，当我们每启动一个容器时，这些容器分配的网卡都是成对的。这使用了evth-pair技术，实际就是一对的虚拟设备接口，它们都是成对出现的，一端连着协议，一端彼此相连。</p><p>正因为有这样的特性，我们一般使用evth-pair来充当一个桥梁，用来连接各种虚拟的网络设备。</p><p>我们可以测试一下两个容器之间是否可以进行网络通信:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 测试容器tomcate1和tomcate2是否可以进行网络通信[可以实现网络通信][root@mysvr ~]# docker exec -it tomcate02 ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.088 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.064 ms64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.065 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结论:我们通过测试发现容器和容器之间是可以进行网络通信的。</p></blockquote><p><img src="http://md.qpfsource.cn/img/Internet21.png"></p><blockquote><p>结论:Tomcat1和Tomcat2是共用一个路由器docker0,所有的容器在不指定网络的情况下，都是通过docker0进行路由的，docker会给每个容器分配一个默认的可用ip。</p></blockquote><blockquote><p>思考:我们编写了一个应用程序，database url=ip,这里的ip是可变的，当分配不同的IP时我们就需要修改对应的配置，如何可以避免这种问题的产生？当数据库IP改变之后不用重启项目，可以通过服务名称进行访问。</p></blockquote><h4 id="9-2、使用–link进行网络连接"><a href="#9-2、使用–link进行网络连接" class="headerlink" title="9.2、使用–link进行网络连接"></a>9.2、使用–link进行网络连接</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 使用服务名称直接ping 是不能进行网络通信的[root@mysvr ~]# docker exec -it tomcate02 ping tomcate01ping: tomcate01: Name or service not known-- 解决方案:使用--link进行网络连接[使用--link后就可以实现通过服务名称通信][root@mysvr ~]# docker run -d -P --name tomcate03 --link tomcate02  tomcata3882d616450a91552be3c85cd30b58065d1b1f09aa7fdda435f1974cb49b38f[root@mysvr ~]# docker exec -it tomcate03 ping  tomcate02PING tomcate02 (172.18.0.3) 56(84) bytes of data.64 bytes from tomcate02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.090 ms64 bytes from tomcate02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.067 ms64 bytes from tomcate02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.065 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向测试查看是否可以进行网络通信:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# docker exec -it tomcate02 ping  tomcate03ping: tomcate03: Name or service not known-- 查询网卡信息[root@mysvr ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE7c53268a287c   bridge    bridge    local40b27fb6afba   host      host      localff6acbf1a27e   none      null      local-- 查看bridge的网络信息[root@mysvr ~]# docker inspect 7c53268a287c[    {        "Name": "bridge",        "Id": "7c53268a287c5f39baa57ddaf9b5b3775e8ddd69e9c26e90811db51651f7d74d",        "Created": "2021-01-02T13:54:23.169475457+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": null,            "Config": [                {                    "Subnet": "172.18.0.0/16",                    "Gateway": "172.18.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {            "36c34aece78983bb71ff09fc2216b7134d3ee51e82a284da97797d072339f38a": {                "Name": "tomcate01",                "EndpointID": "022b97fe69481c0d0209ddd8274d25e3210552c89f62580d9905c461fffbb7b1",                "MacAddress": "02:42:ac:12:00:02",                "IPv4Address": "172.18.0.2/16",                "IPv6Address": ""            },            "41e6d606afd88f74cff2887a20a082ef8300f29dbcf4767290932f1dbcfde3bf": {                "Name": "tomcate02",                "EndpointID": "bc52a35123be5b72d06f0796b9078b5acf5673dc5afe17d1c8150a5ebfde4aa1",                "MacAddress": "02:42:ac:12:00:03",                "IPv4Address": "172.18.0.3/16",                "IPv6Address": ""            },            "a3882d616450a91552be3c85cd30b58065d1b1f09aa7fdda435f1974cb49b38f": {                "Name": "tomcate03",                "EndpointID": "b7dbb76d7d7c926c1811abdb7288e04bf7edd6c87e3f0b69b7c1d7cd17b86fe1",                "MacAddress": "02:42:ac:12:00:04",                "IPv4Address": "172.18.0.4/16",                "IPv6Address": ""            }        },        "Options": {            "com.docker.network.bridge.default_bridge": "true",            "com.docker.network.bridge.enable_icc": "true",            "com.docker.network.bridge.enable_ip_masquerade": "true",            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",            "com.docker.network.bridge.name": "docker0",            "com.docker.network.driver.mtu": "1500"        },        "Labels": {}    }]# 查看tomcate3中的tomcate2的配置[root@mysvr ~]# docker exec -it tomcate03 cat /etc/hosts127.0.0.1localhost::1localhost ip6-localhost ip6-loopbackfe00::0ip6-localnetff00::0ip6-mcastprefixff02::1ip6-allnodesff02::2ip6-allrouters172.18.0.3tomcate02 41e6d606afd8172.18.0.4a3882d616450# 通过观察上述的配置我们发现，当使用了--link后，在对应的host文件中就会增加对应的配置映射关系[host]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意:–link的方式以经不再推荐使用，可以使用自定义网络。</p></blockquote><h4 id="9-3、自定义网络"><a href="#9-3、自定义网络" class="headerlink" title="9.3、自定义网络"></a>9.3、自定义网络</h4><p>容器互联:通过自定义网络环境，我们也可以实现容器互联。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">[root@mysvr ~]# docker network --helpUsage:  docker network COMMANDManage networksCommands:  connect     Connect a container to a network  create      Create a network  disconnect  Disconnect a container from a network  inspect     Display detailed information on one or more networks  ls          List networks  prune       Remove all unused networks  rm          Remove one or more networksRun 'docker network COMMAND --help' for more information on a command.-- 查看所有的docker网络[root@mysvr ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE7c53268a287c   bridge    bridge    local40b27fb6afba   host      host      localff6acbf1a27e   none      null      local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>网络模式：</strong></p><ul><li>bridge:桥接 docker(默认，自己创建的也使用桥接模式)。</li><li>none:不配置网络。</li><li>host:和宿主机共享网络。</li><li>container:容器内网络连接(使用较少)。</li></ul><p><strong>测试自定义网络：</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 以前创建容器时未添加[]内的内容，因为这些内容在容器启动时会默认自动添加，不写的话默认也存在[root@mysvr ~]# docker run -d -P --name tomcate1 [--net bridge] tomcat# docker0默认是不能通过服务名访问的，可以通过--link进行网络连接# 自定义网络[root@mysvr ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1  mynetb7d38a960b8a5c51620f521b2143a07fc77bb025b9dfbf92fff4fd7826c17090[root@mysvr ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE7c53268a287c   bridge    bridge    local40b27fb6afba   host      host      localb7d38a960b8a   mynet     bridge    localff6acbf1a27e   none      null      local# 查看自定义的网络信息[root@mysvr ~]# docker inspect mynet[    {        "Name": "mynet",        "Id": "b7d38a960b8a5c51620f521b2143a07fc77bb025b9dfbf92fff4fd7826c17090",        "Created": "2021-01-03T10:49:11.636673025+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": {},            "Config": [                {                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {},        "Options": {},        "Labels": {}    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用自定义网络环境运行容器：</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 使用自定义网络环境运行容器[root@mysvr ~]# docker run -d -P --name tomcate1 --net mynet tomcat25a2fca99bb4ca73242c4fb900b62a0f8811fb03043d23f62981f5af8e51eb90[root@mysvr ~]# docker run -d -P --name tomcate2 --net mynet tomcata10367d97e4fec127e5fd1877d59c24ee6d91074a6c8449ab7e8665503a124ed# 查看自定义的网络信息[root@mysvr ~]# docker inspect mynet[    {        "Name": "mynet",        "Id": "b7d38a960b8a5c51620f521b2143a07fc77bb025b9dfbf92fff4fd7826c17090",        "Created": "2021-01-03T10:49:11.636673025+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": {},            "Config": [                {                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {            "25a2fca99bb4ca73242c4fb900b62a0f8811fb03043d23f62981f5af8e51eb90": {                "Name": "tomcate1",                "EndpointID": "e6a1b722d400028384c5a901da3a7c9a552368ef2e408e6b2666aab73b9c7250",                "MacAddress": "02:42:c0:a8:00:02",                "IPv4Address": "192.168.0.2/16",                "IPv6Address": ""            },            "a10367d97e4fec127e5fd1877d59c24ee6d91074a6c8449ab7e8665503a124ed": {                "Name": "tomcate2",                "EndpointID": "ceee5a3b6e7807a4517a1c9ddc83e8a0e9d518edf2e94b510211c299e74b42cc",                "MacAddress": "02:42:c0:a8:00:03",                "IPv4Address": "192.168.0.3/16",                "IPv6Address": ""            }        },        "Options": {},        "Labels": {}    }]# 使用自定义网络的容器之间是否可以通过服务名通信[root@mysvr ~]# docker exec -it tomcate1 ping tomcate2PING tomcate2 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcate2.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.066 ms64 bytes from tomcate2.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.064 ms64 bytes from tomcate2.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.069 ms# 通过测试我们发现使用自定义网络后，我们可以通过服务名进行容器之间的通信<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-4、网络联通"><a href="#9-4、网络联通" class="headerlink" title="9.4、网络联通"></a>9.4、网络联通</h4><p><img src="http://md.qpfsource.cn/img/intrrent.png"></p><blockquote><p>思考:如何实现dicker0和mynet之间的网络通信？</p></blockquote><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 通过connect命令实现不同网段的容器之间进行相互通信[root@mysvr ~]# docker network connect --helpUsage:  docker network connect [OPTIONS] NETWORK CONTAINERConnect a container to a networkOptions:      --alias strings           Add network-scoped alias for the container      --driver-opt strings      driver options for the network      --ip string               IPv4 address (e.g., 172.30.100.104)      --ip6 string              IPv6 address (e.g., 2001:db8::33)      --link list               Add link to another container      --link-local-ip strings   Add a link-local address for the container# 进行网络联通[root@mysvr ~]# docker network connect mynet tomcate3# 查看自定义的网络信息，就是将tomcate3放在了自定义的网络环境下[就是一个容器两个IP][root@mysvr ~]# docker network inspect mynet[    {        "Name": "mynet",        "Id": "b7d38a960b8a5c51620f521b2143a07fc77bb025b9dfbf92fff4fd7826c17090",        "Created": "2021-01-03T10:49:11.636673025+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": {},            "Config": [                {                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {            "25a2fca99bb4ca73242c4fb900b62a0f8811fb03043d23f62981f5af8e51eb90": {                "Name": "tomcate1",                "EndpointID": "e6a1b722d400028384c5a901da3a7c9a552368ef2e408e6b2666aab73b9c7250",                "MacAddress": "02:42:c0:a8:00:02",                "IPv4Address": "192.168.0.2/16",                "IPv6Address": ""            },            "2ca81966e6a9cf85a8722ab45858cfc4fb6b7bde698a7ce46a17886755eb1c2a": {                "Name": "tomcate3",                "EndpointID": "2fa2c9e94ab239b930601f460dc7cc19d695f7633390044aa1ad82d9533cae60",                "MacAddress": "02:42:c0:a8:00:04",                "IPv4Address": "192.168.0.4/16",                "IPv6Address": ""            },            "a10367d97e4fec127e5fd1877d59c24ee6d91074a6c8449ab7e8665503a124ed": {                "Name": "tomcate2",                "EndpointID": "ceee5a3b6e7807a4517a1c9ddc83e8a0e9d518edf2e94b510211c299e74b42cc",                "MacAddress": "02:42:c0:a8:00:03",                "IPv4Address": "192.168.0.3/16",                "IPv6Address": ""            }        },        "Options": {},        "Labels": {}    }]# 再次测试查看对应容器是否可以进行网络通信[可以进行网络通信][root@mysvr ~]# docker exec -it tomcate1 ping tomcate3PING tomcate3 (192.168.0.4) 56(84) bytes of data.64 bytes from tomcate3.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.077 ms64 bytes from tomcate3.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.071 ms64 bytes from tomcate3.mynet (192.168.0.4): icmp_seq=3 ttl=64 time=0.065 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-5、微服务打包docker镜像部署"><a href="#9-5、微服务打包docker镜像部署" class="headerlink" title="9.5、微服务打包docker镜像部署"></a>9.5、微服务打包docker镜像部署</h4><h5 id="9-5-1、构建Springboot应用"><a href="#9-5-1、构建Springboot应用" class="headerlink" title="9.5.1、构建Springboot应用"></a>9.5.1、构建Springboot应用</h5><h5 id="9-5-2、打包应用"><a href="#9-5-2、打包应用" class="headerlink" title="9.5.2、打包应用"></a>9.5.2、打包应用</h5><h5 id="9-5-3、编写dockerfile"><a href="#9-5-3、编写dockerfile" class="headerlink" title="9.5.3、编写dockerfile"></a>9.5.3、编写dockerfile</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">FROM java:8COPY *.jar /app.jarCMD ["--server.port=8080"]EXPOSE 8080ENTRYPOINT ["java","-jar","/app.jar"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-5-4、构建镜像"><a href="#9-5-4、构建镜像" class="headerlink" title="9.5.4、构建镜像"></a>9.5.4、构建镜像</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 进行镜像构建docker build -t source  .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="9-5-5、发布运行"><a href="#9-5-5、发布运行" class="headerlink" title="9.5.5、发布运行"></a>9.5.5、发布运行</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 使用镜像运行docker容器docker run -d  -p 8080:8080 --name sourcetest source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consul的基本内容</title>
      <link href="/2021/07/18/consul-de-ji-ben-nei-rong/"/>
      <url>/2021/07/18/consul-de-ji-ben-nei-rong/</url>
      
        <content type="html"><![CDATA[<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p>在SpringCloud中，大部分的组件都具备必选方案。例如服务注册中心、除了我们常见的Eureka之外，像Zookeeper我们也可以直接在SpringCloud中直接使用，同时，Consul也是一种比较重要的服务注册方案。</p><p>Consul是HashiCorp公司通过Go语言开发的一款开源产品。主要提供如下功能：服务发现、服务隔离、服务配置、等相关功能。</p><p>相比于Eureka和Zookeeper，Consul的配置更加一站式。因为其内置了许多微服务常见的需求:服务的发现与注册、分布式一致性协议实现、健康检查、键值对存储、多数据中心等，实现这些功能时我们将不再需要借助那些第三方的组件来完成相关功能。</p><h3 id="2、安装与基本配置"><a href="#2、安装与基本配置" class="headerlink" title="2、安装与基本配置"></a>2、安装与基本配置</h3><h4 id="1、安装环境"><a href="#1、安装环境" class="headerlink" title="1、安装环境"></a>1、安装环境</h4><p>Consul和Eureka不同，Consul是使用Go语言开发的软件平台。使用Consul时，我们首先需要完成Consul的安装。</p><blockquote><p>官网地址:<a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p></blockquote><h5 id="1-1、下载安装压缩包"><a href="#1-1、下载安装压缩包" class="headerlink" title="1.1、下载安装压缩包"></a>1.1、下载安装压缩包</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 使用Wget命令下载软件压缩包至Linux主机wget https://releases.hashicorp.com/consul/1.9.0/consul_1.9.0_linux_amd64.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-2、解压已下载的Zip软件包"><a href="#1-2、解压已下载的Zip软件包" class="headerlink" title="1.2、解压已下载的Zip软件包"></a>1.2、解压已下载的Zip软件包</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 使用unzip命令解压下载完成的软件包,此处解压完成后是一个文件unzip consul_1.9.0_linux_amd64.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-3、启动软件"><a href="#1-3、启动软件" class="headerlink" title="1.3、启动软件"></a>1.3、启动软件</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 启动命令的参数说明:-dev:表示开发环境-ui:表示开启对应的Ui管理页面-node:表示对应节点的名称-Client:表示客户端的访问IP./consul agent -dev -ui -node=consul-dev -client=121.336.155.14[0.0.0.0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4、访问地址，查看结果"><a href="#1-4、访问地址，查看结果" class="headerlink" title="1.4、访问地址，查看结果"></a>1.4、访问地址，查看结果</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- Consul默认启动8500端口http://ip:8500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://md.qpfsource.cn/img/Consul.png"></p><h5 id="1-5、Consul的常用启动参数"><a href="#1-5、Consul的常用启动参数" class="headerlink" title="1.5、Consul的常用启动参数"></a>1.5、Consul的常用启动参数</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-advertise：用于更改我们通知给集群中其他节点的地址，如果未指定默认使用-bind地址作为通知地址。-bind：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0。-bootstrap-expect ：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用-client:  Consul将绑定客户端接口的地址，包括HTTP、DNS、RPC等服务，默认是127.0.0.1，所以不对外提供服务，如果你要对外提供服务改成0.0.0.0-config-file: 要加载的配置文件。-config-dir: 要加载的配置文件目录，里面所有以.json结尾的文件都会被加载-datacenter：指定该agent使用的数据中心，如果未提供，则默认为“ dc1”-disable-host-node-id: 将其设置为true将阻止Consul使用主机上的信息来生成确定性节点ID，而是生成一个随机节点ID，该ID将保留在数据目录中。在同一主机上运行多个Consul代理进行测试时，这很有用。-domain: 设置DNS查询响应的域名，这将会覆盖默认的域名”consul.”-dns-port：监听的DNS端口。这将覆盖默认端口8600-grpc-port：监听的gRPC API端口。默认值-1（禁用gRPC）-http-port：监听的HTTP API端口。这将覆盖默认端口8500-https-port：用于侦听的HTTPS API端口。默认值-1-log-file：将所有Consul代理日志消息写入文件。-join：启动时要加入的另一个Agent的地址。可以多次指定，以指定要加入的多个代理。-rejoin：类似join，但是允许重新连接，直到成功为止。一旦成功加入成员列表中，它将不再尝试加入。 -node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名-server:定义agent运行在server模式，如果不指定该参数则以client模式运行。-server-port：要侦听的服务器RPC端口。这将覆盖默认的服务器RPC端口8300-ui: 启用内置的Web UI服务器和所需的HTTP路由。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、Consul的基本使用"><a href="#2、Consul的基本使用" class="headerlink" title="2、Consul的基本使用"></a>2、Consul的基本使用</h4><h5 id="2-1、首先，我们创建一个简单的服务提供者。这里的服务提供者也就是一个简单的SpringBoot工程，添加如下的依赖"><a href="#2-1、首先，我们创建一个简单的服务提供者。这里的服务提供者也就是一个简单的SpringBoot工程，添加如下的依赖" class="headerlink" title="2.1、首先，我们创建一个简单的服务提供者。这里的服务提供者也就是一个简单的SpringBoot工程，添加如下的依赖:"></a>2.1、首先，我们创建一个简单的服务提供者。这里的服务提供者也就是一个简单的SpringBoot工程，添加如下的依赖:</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2、进行项目的基本配置"><a href="#2-2、进行项目的基本配置" class="headerlink" title="2.2、进行项目的基本配置"></a>2.2、进行项目的基本配置</h5><pre class="line-numbers language-prop" data-language="prop"><code class="language-prop">spring.application.name=consul-providerserver.port=2000#配置相关的Consul信息spring.cloud.consul.host=121.36.XXX.XXXspring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-provider<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3、项目中添加测试接口"><a href="#2-3、项目中添加测试接口" class="headerlink" title="2.3、项目中添加测试接口"></a>2.3、项目中添加测试接口</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"This is a test Consul Service Provider!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4、开启服务发现的功能"><a href="#2-4、开启服务发现的功能" class="headerlink" title="2.4、开启服务发现的功能"></a>2.4、开启服务发现的功能</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token operator">--</span> 添加注解<span class="token class-name">EnableDiscoveryClient</span>，开启服务发现功能<span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsulProviderApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ConsulProviderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4、启动项目，进行测试"><a href="#2-4、启动项目，进行测试" class="headerlink" title="2.4、启动项目，进行测试"></a>2.4、启动项目，进行测试</h5><p><img src="http://md.qpfsource.cn/img/Consul222.png"></p><p>当看到如下内容时，表示当前服务已经成功注册到Consul中。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles抓包配置</title>
      <link href="/2021/07/18/charles-zhua-bao-pei-zhi/"/>
      <url>/2021/07/18/charles-zhua-bao-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Charles配置抓取https协议的数据包"><a href="#Charles配置抓取https协议的数据包" class="headerlink" title="Charles配置抓取https协议的数据包"></a>Charles配置抓取https协议的数据包</h2><h4 id="一、使用Charles抓取移动端https协议的数据包"><a href="#一、使用Charles抓取移动端https协议的数据包" class="headerlink" title="一、使用Charles抓取移动端https协议的数据包"></a>一、使用Charles抓取移动端https协议的数据包</h4><h5 id="1、电脑安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-该步骤可以省略"><a href="#1、电脑安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-该步骤可以省略" class="headerlink" title="1、电脑安装证书[help–>ssl-proxying–>Install Charles Root Certificate] (该步骤可以省略)"></a>1、电脑安装证书[help–&gt;ssl-proxying–&gt;Install Charles Root Certificate] (该步骤可以省略)</h5><h5 id="2、手机安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-on-Mobile-Device-or-Remote-Browser"><a href="#2、手机安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-on-Mobile-Device-or-Remote-Browser" class="headerlink" title="2、手机安装证书[help–>ssl-proxying–>Install Charles Root Certificate on Mobile Device or Remote Browser.]"></a>2、手机安装证书[help–&gt;ssl-proxying–&gt;Install Charles Root Certificate on Mobile Device or Remote Browser.]</h5><h5 id="3、手机访问chls-pro-ssl下载并安装证书-IOS设备需要信任证书"><a href="#3、手机访问chls-pro-ssl下载并安装证书-IOS设备需要信任证书" class="headerlink" title="3、手机访问chls.pro/ssl下载并安装证书(IOS设备需要信任证书)"></a>3、手机访问chls.pro/ssl下载并安装证书(IOS设备需要信任证书)</h5><h5 id="4、设置主机与Port信息-proxy–-gt-ssl-proxying-settings-配置主机为-Port为443"><a href="#4、设置主机与Port信息-proxy–-gt-ssl-proxying-settings-配置主机为-Port为443" class="headerlink" title="4、设置主机与Port信息[proxy–>ssl-proxying-settings],配置主机为*,Port为443"></a>4、设置主机与Port信息[proxy–&gt;ssl-proxying-settings],配置主机为*,Port为443</h5><h5 id="5、-当相关内容设置无效时，可尝试重新下载并信任对应的证书"><a href="#5、-当相关内容设置无效时，可尝试重新下载并信任对应的证书" class="headerlink" title="5、[当相关内容设置无效时，可尝试重新下载并信任对应的证书]"></a>5、[当相关内容设置无效时，可尝试重新下载并信任对应的证书]</h5><h4 id="注意-该方式适用于IOS12以上的所有机型。"><a href="#注意-该方式适用于IOS12以上的所有机型。" class="headerlink" title="注意:该方式适用于IOS12以上的所有机型。"></a>注意:该方式适用于IOS12以上的所有机型。</h4><h4 id="二、使用Charles抓取web浏览器的https请求"><a href="#二、使用Charles抓取web浏览器的https请求" class="headerlink" title="二、使用Charles抓取web浏览器的https请求"></a>二、使用Charles抓取web浏览器的https请求</h4><h5 id="1、电脑安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-必须步骤"><a href="#1、电脑安装证书-help–-gt-ssl-proxying–-gt-Install-Charles-Root-Certificate-必须步骤" class="headerlink" title="1、电脑安装证书[help–>ssl-proxying–>Install Charles Root Certificate] [必须步骤]"></a>1、电脑安装证书[help–&gt;ssl-proxying–&gt;Install Charles Root Certificate] [必须步骤]</h5><h5 id="2、web浏览器安装证书-chls-pro-ssl"><a href="#2、web浏览器安装证书-chls-pro-ssl" class="headerlink" title="2、web浏览器安装证书[chls.pro/ssl]"></a>2、web浏览器安装证书[chls.pro/ssl]</h5><h5 id="3、浏览器导入证书信息-设置为受信任的根证书"><a href="#3、浏览器导入证书信息-设置为受信任的根证书" class="headerlink" title="3、浏览器导入证书信息[设置为受信任的根证书]"></a>3、浏览器导入证书信息[设置为受信任的根证书]</h5><h5 id="4、设置主机与Port信息-proxy–-gt-ssl-proxying-settings-配置端口号为-Port为"><a href="#4、设置主机与Port信息-proxy–-gt-ssl-proxying-settings-配置端口号为-Port为" class="headerlink" title="4、设置主机与Port信息[proxy–>ssl-proxying-settings],配置端口号为*,Port为*"></a>4、设置主机与Port信息[proxy–&gt;ssl-proxying-settings],配置端口号为*,Port为*</h5><h4 id="注-当安装证书或修改代理后相关配置未生效时，可尝试重启Charles或勾选-proxy–-gt-proxy-settings-下的Enable-transparent-Http-Proxying"><a href="#注-当安装证书或修改代理后相关配置未生效时，可尝试重启Charles或勾选-proxy–-gt-proxy-settings-下的Enable-transparent-Http-Proxying" class="headerlink" title="注:当安装证书或修改代理后相关配置未生效时，可尝试重启Charles或勾选[proxy–>proxy-settings]下的Enable transparent Http Proxying"></a>注:当安装证书或修改代理后相关配置未生效时，可尝试重启Charles或勾选[proxy–&gt;proxy-settings]下的Enable transparent Http Proxying</h4>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd的按需加载及主题配置</title>
      <link href="/2021/07/18/ant-zu-jian-shi-xian-an-xu-jia-zai-ji-zhu-ti-pei-zhi/"/>
      <url>/2021/07/18/ant-zu-jian-shi-xian-an-xu-jia-zai-ji-zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="antd的按需加载及主题配置"><a href="#antd的按需加载及主题配置" class="headerlink" title="antd的按需加载及主题配置"></a>antd的按需加载及主题配置</h2><h4 id="1、antd的按需加载"><a href="#1、antd的按需加载" class="headerlink" title="1、antd的按需加载"></a>1、antd的按需加载</h4><p><code>antd</code> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。使用<code>antd</code>可以极大的简化我们的开发速度，但是，由于在默认情况下我们使用antd的相关包文件时，它会默认将所有的组件的内容进行打包处理，这样会严重的影响我们程序的执行性能。因此，我们可使用按需加载的方式进行配置，防止不必要的内容被打包在我们的项目应用中，从而提高我们程序的性能。</p><h5 id="antd实现按需打包的步骤"><a href="#antd实现按需打包的步骤" class="headerlink" title="antd实现按需打包的步骤:"></a>antd实现按需打包的步骤:</h5><p>1、下载相关的依赖项</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">-- 此处下载内容较多，需更换镜像或使用yarn进行下载npm install react-app-rewired customize-cra babel-plugin-import<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、定义加载配置的js文件config-overrides.js，在项目的根目录下创建该文件而非src目录下</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">const {override, fixBabelImports} = require('customize-cra');module.exports = override(fixBabelImports('import', {libraryName: 'antd',libraryDirectory: 'es',style: 'css',}),);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、修改package.json文件</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">"scripts": {"start": "react-app-rewired start","build": "react-app-rewired build","test": "react-app-rewired test","eject": "react-scripts eject"},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="antd实现自定义主题配置"><a href="#antd实现自定义主题配置" class="headerlink" title="antd实现自定义主题配置:"></a>antd实现自定义主题配置:</h5><p>1、下载相关依赖</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">yarn add less less-loader<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、修改配置文件  config-overrides.js</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">const {override, fixBabelImports,addLessLoader} = require('customize-cra');module.exports = override(// 针对antd实现按需打包:使用babel-plugin-importfixBabelImports('import', {libraryName: 'antd',libraryDirectory: 'es',style: true,  //css 自动打包相关样式,修改样式时此处修改为true}),//修改样式的自定义loaderaddLessLoader({// 新版本中此处需要使用lessOptions进行包裹lessOptions:{javascriptEnabled: true,modifyVars: {'@primary-color': '#1DA57A'},}}),);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2021/07/18/git-ji-chu/"/>
      <url>/2021/07/18/git-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、-Git概述"><a href="#一、-Git概述" class="headerlink" title="一、 Git概述"></a>一、 Git概述</h3><h4 id="1、Git历史"><a href="#1、Git历史" class="headerlink" title="1、Git历史"></a>1、Git历史</h4><p>Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 </p><p>他们对新的系统制订了若干目标:</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><h4 id="2、Git与SVN对比"><a href="#2、Git与SVN对比" class="headerlink" title="2、Git与SVN对比"></a>2、Git与SVN对比</h4><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。</p><p>集中式版本控制工具缺点:</p><p>1、服务器单点故障</p><p>2、容错性差</p><p><img src="http://md.qpfsource.cn/img/Git1.png"></p><p>Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库:</p><p>仓库分类:本地仓库和远程仓库</p><p>1、本地仓库：是在开发人员自己电脑上的Git仓库</p><p>2、远程仓库：是在远程服务器上的Git仓库</p><p>Clone：克隆，就是将远程仓库复制到本地</p><p>Push：推送，就是将本地仓库代码上传到远程仓库</p><p>Pull：拉取，就是将远程仓库代码下载到本地仓库</p><p><img src="http://md.qpfsource.cn/img/Git2.png"></p><h4 id="3、Git工作流程"><a href="#3、Git工作流程" class="headerlink" title="3、Git工作流程"></a>3、Git工作流程</h4><p>工作流程如下：</p><p>1．从远程仓库中克隆代码到本地仓库</p><p>2．从本地仓库中checkout代码然后进行代码修改</p><p>3.在提交前先将代码提交到暂存区</p><p>4．提交到本地仓库。本地仓库中保存修改的各个历史版本</p><p>5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</p><p><img src="http://md.qpfsource.cn/img/Git3.png"></p><h3 id="二、Git代码托管服务"><a href="#二、Git代码托管服务" class="headerlink" title="二、Git代码托管服务"></a>二、Git代码托管服务</h3><h4 id="1、常用的Git代码托管服务"><a href="#1、常用的Git代码托管服务" class="headerlink" title="1、常用的Git代码托管服务"></a>1、常用的Git代码托管服务</h4><p>前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p><p>gitHub（ 地址:<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub。</p><p>码云（地址:<a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快。</p><p>GitLab （地址:<a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务</p><h4 id="2、创建远程仓库"><a href="#2、创建远程仓库" class="headerlink" title="2、创建远程仓库"></a>2、创建远程仓库</h4><p>1、注册账号</p><p>2、创建仓库</p><p>3、添加成员</p><h3 id="三、Git常用命令"><a href="#三、Git常用命令" class="headerlink" title="三、Git常用命令"></a>三、Git常用命令</h3><h4 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h4><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。</p><p>设置用户信息：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">git config --global user.name “source”git config --global user.email “source@163.cn”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看配置信息:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">git config --listgit config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>通过上面的命令设置的信息会保存在~/.gitconfig文件中</strong></p><h4 id="2、获取Git仓库"><a href="#2、获取Git仓库" class="headerlink" title="2、获取Git仓库"></a>2、获取Git仓库</h4><p>要使用Git对我们的代码进行版本控制，首先需要获得Git仓库</p><p>获取Git仓库通常有两种方式:</p><p>1、在本地初始化一个Git仓库</p><p>2、  从远程仓库克隆</p><h4 id="3、本地初始化Git仓库"><a href="#3、本地初始化Git仓库" class="headerlink" title="3、本地初始化Git仓库"></a>3、本地初始化Git仓库</h4><p>操作过程如下:</p><p>1、在电脑的任意位置创建一个空目录（例如repo1）作为我们的本地Git仓库。</p><p>2、进入这个目录中，点击右键打开Git bash窗口。</p><p>3、执行命令git init。</p><p><strong>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</strong></p><h4 id="4、从远程克隆仓库"><a href="#4、从远程克隆仓库" class="headerlink" title="4、从远程克隆仓库"></a>4、从远程克隆仓库</h4><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地。</p><p>命令形式为：git clone 远程Git仓库地址</p><h4 id="5、工作目录、暂存区以及版本库概念"><a href="#5、工作目录、暂存区以及版本库概念" class="headerlink" title="5、工作目录、暂存区以及版本库概念"></a>5、工作目录、暂存区以及版本库概念</h4><p>版本库:前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等。</p><p>工作目录(工作区):包含.git文件夹的目录就是工作目录，主要用于存放开发的代码。</p><p>暂存区:.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方。</p><p><img src="http://md.qpfsource.cn/img/Git4.png"></p><h4 id="6、Git工作目录下文件的两种状态"><a href="#6、Git工作目录下文件的两种状态" class="headerlink" title="6、Git工作目录下文件的两种状态"></a>6、Git工作目录下文件的两种状态</h4><p>Git工作目录下的文件存在两种状态:</p><p>untracked 未跟踪（未被纳入版本控制）</p><p>tracked 已跟踪（被纳入版本控制）</p><p>​        1、Unmodified 未修改状态</p><p>​        2、Modified 已修改状态</p><p>​        3、Staged 已暂存状态</p><p><strong>文件的状态会随着我们执行Git的命令发生变化</strong></p><h4 id="7、本地仓库操作"><a href="#7、本地仓库操作" class="headerlink" title="7、本地仓库操作"></a>7、本地仓库操作</h4><h5 id="1、git-status-查看文件状态（-s-使输出更简洁）"><a href="#1、git-status-查看文件状态（-s-使输出更简洁）" class="headerlink" title="1、git status 查看文件状态（-s 使输出更简洁）"></a>1、git status 查看文件状态（-s 使输出更简洁）</h5><h5 id="2、git-add-将未跟踪的文件加入暂存区"><a href="#2、git-add-将未跟踪的文件加入暂存区" class="headerlink" title="2、git add 将未跟踪的文件加入暂存区"></a>2、git add 将未跟踪的文件加入暂存区</h5><h5 id="3、git-reset-将暂存区的文件取消暂存"><a href="#3、git-reset-将暂存区的文件取消暂存" class="headerlink" title="3、git reset 将暂存区的文件取消暂存"></a>3、git reset 将暂存区的文件取消暂存</h5><h5 id="4、git-commit-将暂存区的文件修改提交到本地仓库"><a href="#4、git-commit-将暂存区的文件修改提交到本地仓库" class="headerlink" title="4、git commit 将暂存区的文件修改提交到本地仓库"></a>4、git commit 将暂存区的文件修改提交到本地仓库</h5><h5 id="5、git-rm-删除文件（删除文件后续提交至本地仓库）"><a href="#5、git-rm-删除文件（删除文件后续提交至本地仓库）" class="headerlink" title="5、git rm 删除文件（删除文件后续提交至本地仓库）"></a>5、git rm 删除文件（删除文件后续提交至本地仓库）</h5><h5 id="6、将相关文件添加至git版本控制系统的忽略列表"><a href="#6、将相关文件添加至git版本控制系统的忽略列表" class="headerlink" title="6、将相关文件添加至git版本控制系统的忽略列表:"></a>6、将相关文件添加至git版本控制系统的忽略列表:</h5><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><pre class="line-numbers language-none"><code class="language-none"># no .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7、git-log-查看日志记录"><a href="#7、git-log-查看日志记录" class="headerlink" title="7、git log 查看日志记录"></a>7、git log 查看日志记录</h5><h4 id="8、远程仓库操作"><a href="#8、远程仓库操作" class="headerlink" title="8、远程仓库操作"></a>8、远程仓库操作</h4><p>前面执行的命令操作都是针对的本地仓库，本章节我们会学习关于远程仓库的一些操作，具体包括：</p><p>1、查看远程仓库</p><p>2、添加远程仓库</p><p>3、从远程仓库克隆</p><p>4、移除无效的远程仓库</p><p>5、从远程仓库中抓取与拉取</p><p>6、推送到远程仓库</p><h5 id="1、查看远程仓库"><a href="#1、查看远程仓库" class="headerlink" title="1、查看远程仓库"></a>1、查看远程仓库</h5><p>如果想查看已经配置的远程仓库服务器，可以运行 git remote（-v 显示详细信息  ）[git remote show origin] 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。</p><h5 id="2、添加远程仓库"><a href="#2、添加远程仓库" class="headerlink" title="2、添加远程仓库"></a>2、添加远程仓库</h5><p>运行 git remote add &lt; shortname &gt; &lt; url &gt; 添加一个新的远程 Git 仓库，同时指定一个可以引用的简写。</p><h5 id="3、从远程仓库克隆"><a href="#3、从远程仓库克隆" class="headerlink" title="3、从远程仓库克隆"></a>3、从远程仓库克隆</h5><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆仓库的命令格式是 git clone [url] </p><h5 id="4、移除无效的远程仓库"><a href="#4、移除无效的远程仓库" class="headerlink" title="4、移除无效的远程仓库"></a>4、移除无效的远程仓库</h5><p>如果因为一些原因想要移除一个远程仓库 ，可以使用 git remote rm。</p><p><strong>注意：此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库。</strong></p><h5 id="5、从远程仓库中抓取与拉取"><a href="#5、从远程仓库中抓取与拉取" class="headerlink" title="5、从远程仓库中抓取与拉取"></a>5、从远程仓库中抓取与拉取</h5><p>git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge。</p><p>git pull 是从远程仓库获取最新版本并merge到本地仓库。</p><p><strong>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories。</strong></p><h5 id="6、推送到远程仓库"><a href="#6、推送到远程仓库" class="headerlink" title="6、推送到远程仓库"></a>6、推送到远程仓库</h5><p>当你想分享你的代码时，可以将其推送到远程仓库。 </p><p>命令形式：<strong>git push - remote-name(远程地址)  - branch-name(远程分支名)</strong></p><h3 id="4、Git分支"><a href="#4、Git分支" class="headerlink" title="4、Git分支"></a>4、Git分支</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。</p><p><strong>常见的操作分支的相关命令:</strong></p><h4 id="1、查看分支"><a href="#1、查看分支" class="headerlink" title="1、查看分支"></a>1、查看分支</h4><h5 id="1、列出所有本地分支"><a href="#1、列出所有本地分支" class="headerlink" title="1、列出所有本地分支"></a>1、列出所有本地分支</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git branch --列出本地的所有分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2、列出远程所有分支"><a href="#2、列出远程所有分支" class="headerlink" title="2、列出远程所有分支"></a>2、列出远程所有分支</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git branch -r --列出远程仓库的所有分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3、列出所有本地和远程分支"><a href="#3、列出所有本地和远程分支" class="headerlink" title="3、列出所有本地和远程分支"></a>3、列出所有本地和远程分支</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git branch -a --列出本地和远程的所有分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、创建分支"><a href="#2、创建分支" class="headerlink" title="2、创建分支"></a>2、创建分支</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git branch 分支名称  --创建指定名称的代码分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、切换分支"><a href="#3、切换分支" class="headerlink" title="3、切换分支"></a>3、切换分支</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git checkout 分支名称  --切换到指定名称的分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、推送至远程仓库的分支"><a href="#4、推送至远程仓库的分支" class="headerlink" title="4、推送至远程仓库的分支"></a>4、推送至远程仓库的分支</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git push origin 分支名称  --推送相关内容到指定分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5、合并分支"><a href="#5、合并分支" class="headerlink" title="5、合并分支"></a>5、合并分支</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git merge 分支名称 --将指定分支和当前所处的分支进行合并<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决。</p><h4 id="6、删除分支"><a href="#6、删除分支" class="headerlink" title="6、删除分支"></a>6、删除分支</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git branch -d 分支名称  --删除仓库中的指定分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D。</p><p><strong>删除远程分支,需要使用如下的操作命令:</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git push origin -d 分支名称  --删除远程仓库的指定分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、Git标签"><a href="#5、Git标签" class="headerlink" title="5、Git标签"></a>5、Git标签</h3><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。标签指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。</p><h4 id="1、列出tag信息"><a href="#1、列出tag信息" class="headerlink" title="1、列出tag信息"></a>1、列出tag信息</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git tag --列出所有tag信息git show [tag] --查看tag信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2、创建新标签"><a href="#2、创建新标签" class="headerlink" title="2、创建新标签"></a>2、创建新标签</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git tag 标签名称  --创建指定名称的标签标记<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、将标签推送至远程仓库"><a href="#3、将标签推送至远程仓库" class="headerlink" title="3、将标签推送至远程仓库"></a>3、将标签推送至远程仓库</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git push origin 标签名称  --推送指定的tag标记至远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、检出标签"><a href="#4、检出标签" class="headerlink" title="4、检出标签"></a>4、检出标签</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git checkout -b   分支名称  标签名称  --新建分支，指向指定的标签<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5、删除标签"><a href="#5、删除标签" class="headerlink" title="5、删除标签"></a>5、删除标签</h4><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git tag -d 标签名称   --删除本地指定名称的标签git push origin:refs/tags/标签名称  --删除指定名称的远程标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 版本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/18/hello-world/"/>
      <url>/2021/07/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
